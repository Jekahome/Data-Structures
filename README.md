## Зачем нужно знать структуры данных и чем они полезны.

Хорошо подобранная структура данных позволяет эффективно манипулировать этими данными. 
Эффективно манипулировать - это про минимум занимаемой памяти, максимум скорости и производительность, масштабируемость, определенная логика, поведение, удобно, гибко, понятно ...  
 
- Stack
- Queue/Deque
- Linked list


## Stack
    
LIFO (last-in, first-out) "Последним вошел - первым вышел"

**Чем полезен Stack?**

Особенности поведением Stack. 

- Поведение рекурсии.
- Корректность выражения со скобками.
- Перевернуть слово — поместите все буквы в стопку и вытащите их. Из-за порядка стека LIFO буквы будут расположены в обратном порядке.
- В компиляторах — компиляторы используют стек для вычисления значения выражений типа `2 + 4 / 5 * (7 - 9)` путем преобразования выражения в префиксную или постфиксную форму.
- В браузерах — кнопка «Назад» в браузере сохраняет в стопке все URL-адреса, которые вы посещали ранее. Каждый раз, когда вы посещаете новую страницу, она добавляется поверх стека. При нажатии кнопки «Назад» текущий URL-адрес удаляется из стека и открывается доступ к предыдущему URL-адресу.

Сложность алгоритма для операции `push` и `pop` занимают постоянное время, т. е. `O(1)`.

**Способы реализации `Stack`**:

- Стек через `Array`, фиксированного размера, поиск `O(n)`
- Стек через `Vec`, безразмерный, поиск `O(n)`
- Стек через `Linked list`, безразмерный, поиск `O(n)`, для двунаправленного поиск `O(n/2)`, возможность разбивать/объединять

[Stack](https://www.programiz.com/dsa/stack)

[Bad Stack](https://rust-unofficial.github.io/too-many-lists/first.html)

[Ok Stack](https://rust-unofficial.github.io/too-many-lists/second.html)

[Persistent Stack](https://rust-unofficial.github.io/too-many-lists/third.html)

[Визуализация](https://www.cs.usfca.edu/~galles/visualization/StackArray.html) 

 
## Queue

FIFO (first-in, first-out) "Первым пришел - первым ушел»"

Сложность алгоритма для операции `push` занимают постоянное время, т. е. `O(1)`.
Затратная операции `pop` если реализация через Vec придется сдвигать элементы. 

**Чем полезна Queue?**

- Queue полезна своим `поведением`.  
- Queue необходима для решения низкоуровневых задач, таких как планирование заданий CPU,
- Для моделирования реальной очереди - например, запросов на техническую поддерку, которые необходимо обрабатывать последовательно.  

**Способы реализации `Queue`**:

- Queue через `Rc`
- Queue через `Vec`
- Queue через `Linked list`

[VecDeque](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)
 
## Linked list

`Linked list` - содержит в каждом елементе указатель на следующий елемент

**Чем полезен Linked list?**

- Вам нужно много разбивать или объединять большие списки. 
- Вы делаете потрясающую параллельную работу без блокировки.

В большинстве случаев 99% вам следует просто использовать Vec (стек массивов),и остальные 1% времени вам следует использовать VecDeque
`Linked list` прекрасная структура данных с несколькими замечательными вариантами использования, но те случаи использования являются исключительными, а не обычными.
В функциональном языке Односвязные списки — ваш основной инструмент управления потоком управления, но они действительно плохой способ хранить кучу данных и запрашивать их.

**Плюсы:**

- динамический размер
- операция вставки/удаления в начало быстрее чем у динамического массива т.е. вектора (у вектора удаление `O(n)` из-за перестановки элементов)
- Сила `Linked list` заключается в возможности разорвать цепочку и снова присоединиться к ней.
- `Linked list` решает проблему массивов фиксированной размерности тем что может динамически расширятся.
- `Linked list` решает проблему динамических массивов тем что нет необходимости сдигать элементы справа.

**Минусы:** 

- доступ по индексу за `O(n)` (в худшем случае), для двунаправленного `O(n/2)` из-за точки входа из головы или хвоста
- `Linked list` доступ по индексу O(n), а у массива O(1)

[Linked list](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Rust/blob/master/Chapter04/src/skip_list.rs)


## Trees

[Trees](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Rust/tree/master/Chapter05/src)

[Hands-On-Data-Structures-and-Algorithms-with-Rust](https://books.google.es/books?id=gYKFDwAAQBAJ&printsec=frontcover&redir_esc=y#v=onepage&q&f=false)



```
Элементарные структуры данных
Хеширование и хеш-таблицы
Бинарные структуры поиска
Красно-черные деревья
Расширение структур данных
```